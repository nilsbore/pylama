>from pylama.common import documentclass
>documentclass("proc")
>from pylama.common import *
>from pylama.layout import centering, raggedleft, raggedright, center
>from pylama.convenience import latex, text
>from pylama.table import table, setcell
>from pylama.figure import figure, includegraphics, figuretable, subfigure
>from pylama.code import code, verbatim
>from pylama.hyperref import url

>title = "pylama: Make typesetting great again"
>author = "Nils Bore"

>begin_document()
>make_title(title, author)

>intro = section("Introduction")

># This is a short, one-line comment

>comment()
    This is a long
    comment with
    several lines.

Pylama can be best described as a wrapper around the
>verbatim("LaTeX")
typesetting system. It attempts to provide a cleaner syntax for your
standard document while still allowing you to add latex inline when needed.
The pylama language is built on top of the Python interpreter and,
as opposed to
>verbatim("LaTeX")
the language is inspired by Python's indentation based grouping of code and text.
To execute code within your pylama document, you start the line with a
>verbatim(">")
, similar to command prompts like bash. Use one or multiple lines depending
on the complexity of the task, all python code and libraries can be imported
and used.

To start out your document, you typically type something like
>code()
    >from pylama.common import *
    >documentclass("proc")
. With this done, you can start building your document. Variables in
the document are stored in a global context, so if you want to provide the
environment with the basics and start out your document, you can type:
>code()
    >title = "pylama: Make typesetting great again"
    >author = "Nils Bore"

    >begin_document()
    >make_title(title, author)
You declare subsections with respect to the parent section, avoiding
having to type "sub" too many times and helping you keep track of the hierarchy.
>code()
    >maths = intro.subsection("Maths")
Too get more familiar with the language, let's look at how we can use pylama for maths.

>maths = intro.subsection("Maths")

Equations, like
>equation1 = equation()
    A*A = A^2
can be declared with the following syntax:
>code()
    >equation1 = equation()
        A*A = A^2
Note the
>verbatim("equation1")
assignment preceding the equation declaration. This gives us a handle
that we can use to reference the equation later in the document using
the syntax
>verbatim(">ref(equation1)")
with the result:
>ref(equation1)
. This has the great advantage that we can actually check if the variable
is present in the current context and throw and error if that is not the case.
In latex this would quietly fail with a question mark in the final document.

The other important thing to note is that there is an indent before
the actual equation text. This declares that the text is a child of
the
>verbatim("equation()")
declaration. The equation environment takes care of processing the
formula into text that can be inserted into the final
>verbatim("LaTeX")
document. The indentation based syntax is a cornerstone of the pylama
language and allows these so called contexts to be nested arbitrarily deep.
The next section delves deeper into contexts.

>items = intro.subsection("Lists and Blocks")

Item lists are a good example for illustrating nested text blocks.
At the top level sits an
>verbatim(">itemize()")
or
>verbatim(">enumerate()")
declaration. In the indented level, as children of the
>verbatim(">itemize()")
, sit several
>verbatim(">item()")
which in turn have their own children, typically text, that
declare the content of the respective items. A complete list can be
declared as
>code()
    >itemize()
        >item()
            Item 1!
        >item()
            Item 2!
        >item()
            Item 3!
which results in the following list:
>itemize()
    >item()
        Item 1!
    >item()
        Item 2!
    >item()
        Item 3!
Note that the children block themselves can contain one or multiple
text or code blocks and that they can be layered in several steps.
This is illustrated in the next section, where we mix text and
figures inside a table environment.

>tables = intro.subsection("Tables and Variables")

Usually, variables in pylama are declared in a global scope. For example,
if you declare a variable
>verbatim(">a=3")
anywhere in your document, even inside a block, it will be accessible anywhere
after that declaration. This allows you to reference a nested block even
when you are on a higher level in the block hierarchy, as we will see in
the subfigure example. However, there is one exception to this in the form
of local variables. Local variables are declared by providing keyword
arguments to the block functions. In the example below,
>verbatim("rows, cols")
and
>verbatim("caption")
are local variables and can only be referenced within the child block.
Notice how we can use them in the table definition to display the size of the table.
>table_example_1 = code(caption = "The tables are indexed by row col in a numpy matrix")
    >table(rows=2, cols=3, caption="A table.")
        >centering()
        >setcell(0, 0)
            Figure:
        >setcell(0, 1)
            Rows:
        >setcell(0, 2)
            Columns:
        >setcell(1, 0)
            >includegraphics(image="birds.png", scale=0.3)
        >setcell(1, 1)
            >text(rows)
        >setcell(1, 2)
            >text(cols)
># A lazy provides two methods, .string() and .add()
># String simply removes the generated latex text as a string
># while add inserts the content in the main latex document
>table_caption_1 = lazy()
    The table showcases how to assign table cells by indices and
    how you can include contexts within each others. The image
    showcased in all figures is created by BanzaiTokyo,
    >url("http://www.iconarchive.com/show/ugly-birds-icons-by-banzaitokyo/angor-icon.html")
    . See table example Listing
    >ref(table_example_1)
    for code.
>ss = table_caption_1.string()

>table_1 = table(rows=2, cols=3, width="\textwidth", caption=ss)
    >centering()
    >setcell(0, 0)
        Figure:
    >setcell(0, 1)
        Rows:
    >setcell(0, 2)
        Columns:
    >setcell(1, 0)
        >includegraphics(image="birds.png", scale=0.3)
    >setcell(1, 1)
        >text(rows)
    >setcell(1, 2)
        >text(cols)
The result can be viewed in Table
>ref(table_1)
. Note that indexing the blocks like this might be a slightly clumsy way of
defining the contents of your table. Instead, we might use python lists to
define the table below. Looping through and setting the blocks appropriately
allows us to express this more compactly.
>table_example_2 = code(caption="Python and pylama interoperation.")
    >table_contents = [["(Observations)", "Finch", "Seagull", "Crow", "Pigeon", "Hawk"],\
    >                  ["Sea", 2, 10, 1, 3, 4],\
    >                  ["Park", 4, 2, 6, 8, 0],\
    >                  ["Cliff", 2, 4, 1, 0, 2]]
    >table(rows=4, cols=6, caption="Bird places.")
        >centering()
        >for r in range(0, rows):
        >    for c in range(0, cols):
        >        setcell(r=r, c=c)
            Obs:
            >text(table_contents[r][c])
>table_caption_2 = lazy()
    This example showcases how you can define a table in python and directly import it into pylama.
    For the code generating this table, look at Listing
    >ref(table_example_2)
    .
>ss = table_caption_2.string()

>table_contents = [["(Observations)", "Finch", "Seagull", "Crow", "Pigeon", "Hawk"],\
>                  ["Sea", 2, 10, 1, 3, 4],\
>                  ["Park", 4, 2, 6, 8, 0],\
>                  ["Cliff", 2, 4, 1, 0, 2]]
>table_2 = table(rows=4, cols=6, caption=ss)
    >centering()
    >for r in range(0, rows):
    >    for c in range(0, cols):
    >        setcell(r=r, c=c)
        Obs:
        >text(table_contents[r][c])
The resulting table is shown in Table
>ref(table_2)
.

>figures = section("Figures")

>code(caption = "Declaring a figure is a oneliner.")
    >f1 = figure(caption="Some lovely red birds", image="birds.png", placement="htpb")
        >center()
>f1 = figure(caption="Some lovely red birds", image="birds.png", placement="htpb", scale=0.6)
    >center()

>latex("Figureref: %s" % f1)
Just referencing figure 1:
>ref(f1)

>#print I

>subfigures = figures.subsection("Subfigures")

>code(caption = "Figuretables are similar to tables with subfigures in the cells")
    >s1 = figuretable(rows=1, cols=4, caption="Birds mr table")
        >print cell.shape
        >print rows
        >print cols
        >center()
        >setcell(0, 0)
            >subfigure(caption="Birds 1", image="birds.png", scale=0.6)
                >center()
        >setcell(0, 1)
            >subfigure(caption="Birds 2", image="birds.png", scale=0.6)
                >center()
        >setcell(0, 2)
            >subfigure(caption="Birds 3", image="birds.png", scale=0.6)
                >center()
        >setcell(0, 3)
            >sf1 = subfigure(caption="Birds 4", image="birds.png", scale=0.6)
                >center()

>caption="Hej!"

>s1 = figuretable(rows=1, cols=4, caption="Birds mr table")
    >print cell.shape
    >print rows
    >print cols
    >center()
    >setcell(0, 0)
        >subfigure(caption="Birds 1", image="birds.png", scale=0.4)
            >center()
    >setcell(0, 1)
        >subfigure(caption="Birds 2", image="birds.png", scale=0.4)
            >center()
    >setcell(0, 2)
        >subfigure(caption="Birds 3", image="birds.png", scale=0.4)
            >center()
    >setcell(0, 3)
        >sf1 = subfigure(caption="Birds 4", image="birds.png", scale=0.4)
            >center()

>print caption

Referencing Equation
>latex("Eqref: %s" % equation1)
>ref(equation1)
And finally, the figure table, Figure
>ref(s1)
and the cell:
>ref(sf1)

>details = section("Details")
>lazys = details.subsection("Lazy blocks")

Pylama is designed to make the common things easy while making the hard
things possible. In that spirit, e.g. captions of figures and tables are
provided as strings to the block function of the figure or table.
However, sometimes you would like the captions themselves to be defined
using the pylama functions and blocks. This is where the
>verbatim("lazy()")
block function comes in. It enables you to define a block like:
>code()
    >lazy_1 = lazy()
        This is text that will only get added later.
This block will not get added in the text in that place of its declaration.
Instead it will get added when you call
>verbatim("lazy\_1.add()")
. However, you could instead call
>verbatim("ss = lazy\_1.string()")
, resulting in a string
>verbatim("ss")
with the block evaluated as text, which you can then provide as the
caption argument to a figure, table, or other block function.
Several of the more complex captions in the examples of this document
were generated in this way.

>contexts = details.subsection("Extending through Contexts")

Inside each block you have access to a variety of introspection details.
Below are some examples of what you can access for example inside an equation block.
>code()
    >equation()
        A + A = 2A
        ># prints "4", the current indent level:
        >print Context.context.indent
        ># prints "A + A = 2A", the first child:
        >print Context.parent.children[0].text
        ># prints "0" as this block has no children:
        >print len(Context.children)

>inputs = section("Combining files")

>code(caption = ".pymd files can be included in each other using the input command.")
    >input("test/input.pymd")

>code(caption = "This is the content of the test/input.pymd file")
    This was written in another file!

>input("test/input.pymd")

>references = section("References")

The following code cites a reference and adds a bibliography file to
the document:

>code()
    >cite("knuth1979tex")
    >add_bibliography("main", "ieeetr")

This results in the reference
>cite("knuth1979tex")
and a bibliography at the end of the document.
>add_bibliography("main", "ieeetr")

>end_document()
